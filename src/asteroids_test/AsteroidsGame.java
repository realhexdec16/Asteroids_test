package asteroids_test;import java.awt.*;import java.awt.event.*;import java.io.IOException;import java.util.ArrayList;import javax.swing.BorderFactory;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextField;@SuppressWarnings("serial")public class AsteroidsGame extends JFrame implements KeyListener,ActionListener,MouseMotionListener{JPanel mainpanel;JPanel Score;JButton exit;JTextField scorefield;JTextField hitratio;public PauseMenu pause;boolean enter=false; Thread thread;Dimension dim;Image img;SoundLoader audio=null;Thread audiothread;Graphics g;long endTime, startTime, framePeriod;EventQueue master_queue=new EventQueue();Ship ship;	//boolean paused; // True if the game is paused. Enter is the pause keyArrayList<Shot> shots;int numShots;boolean shooting;public boolean paused=false;int shotmax=0;int score1=0;int score=0;int hits;Asteroid[] asteroids; //the array of asteroidsint numAsteroids; //the number of asteroids currently in the arraydouble astRadius, minAstVel ,maxAstVel; //values used to create asteroidsint astNumHits,astNumSplit;int level; //the current level numberToneRun tone=new ToneRun();EngineSound engine;public Thread keys=new Thread();private static AsteroidsGame asteroidz;	public AsteroidsGame(String title){super(title);this.setDefaultCloseOperation(EXIT_ON_CLOSE);this.setBounds(500,200,(int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(),(int)Toolkit.getDefaultToolkit().getScreenSize().getHeight());this.setResizable(false);this.setUndecorated(true);this.setLocationRelativeTo(null);scorefield=new JTextField(score1);scorefield.setBounds(50,30,180,30);scorefield.setFont(new Font("Gulim",4,15));scorefield.setForeground(Color.cyan);scorefield.setBorder(null);scorefield.setOpaque(false);scorefield.setEditable(false);scorefield.setHighlighter(null);scorefield.addKeyListener(this);exit=new JButton("Exit"){	protected void paintComponent(Graphics gr){super.paintComponent(gr);		exit.setContentAreaFilled(false);				 final Graphics2D g2d1=(Graphics2D)gr.create();		 RenderingHints hints1 = new RenderingHints(					RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);					RenderingHints render1 =new RenderingHints(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);					hints1.add(render1);					g2d1.setRenderingHints(hints1);		g2d1.setStroke(new BasicStroke(2));		g2d1.setColor(new Color(255,255,255));		g2d1.drawRect(2, 2,96,26);		//repaint();	}};exit.setBounds((int)Toolkit.getDefaultToolkit().getScreenSize().getWidth()-100,(int)Toolkit.getDefaultToolkit().getScreenSize().getHeight()-30,100,30);exit.setFont(new Font("Gulim",4,18));exit.setOpaque(false);//exit.setBorderPainted(false);exit.setForeground(new Color(255,255,255));exit.setOpaque(false);exit.setFocusPainted(false);exit.addActionListener(this);exit.setFocusable(false);//exit.addKeyListener(this);Score=new JPanel(){	@Override	protected void paintComponent(Graphics g1){		super.paintComponent(g1);		Graphics2D g2d2=(Graphics2D)g1.create();		 RenderingHints hints2 = new RenderingHints(					RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);					RenderingHints render1 =new RenderingHints(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);					hints2.add(render1);					g2d2.setRenderingHints(hints2);					g2d2.setColor(new Color(255,255,255));					g2d2.setStroke(new BasicStroke(2));					g2d2.drawRect(0,0,150,100);							}};Score.setBounds(0,(int)Toolkit.getDefaultToolkit().getScreenSize().getHeight()-100,152,102);Score.add(scorefield);pause=new PauseMenu(){	@Override 	 public void paintComponent(Graphics gr){	     super.paintComponent(gr);	     //background-------------------	     Graphics2D g2d1=(Graphics2D)gr.create();	     RenderingHints hints1 = new RenderingHints(					RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);					RenderingHints render1 =new RenderingHints(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_DEFAULT);					hints1.add(render1);					g2d1.setRenderingHints(hints1);					g2d1.setColor(new Color(0,0,0));					g2d1.fillRoundRect(2, 2, width-5, height-5, 80, 80);	     g2d1.setColor(new Color(255,255,255));	     g2d1.setStroke(new BasicStroke(5));	     g2d1.drawRoundRect(2,2,width-5,height-5,80,80);	}};	pause.addMouseMotionListener(this);	pause.resume.addActionListener(this);mainpanel=new JPanel(){	@Override	protected void paintComponent(Graphics gfx){		super.paintComponent(gfx);		//this.mainpanel.paint(gfx);		  Graphics2D g2d1=(Graphics2D)g.create();	     RenderingHints hints1 = new RenderingHints(					RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);					RenderingHints render1 =new RenderingHints(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);					hints1.add(render1);					g2d1.setRenderingHints(hints1);					g.setColor(Color.black);		g.fillRect(0,0,(int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(),(int)Toolkit.getDefaultToolkit().getScreenSize().getHeight());				/*for(int i=0;i<numShots;i++){ //draw all the shots on the screen			break;			shots[i].draw(g);			}*/		//for(Shot shot:shots){		//	shot.draw(g2d1);		//}		for(int i=0;i<shots.size();i++){			shots.get(i).draw(g2d1);		}		for(int i=0;i<numAsteroids;i++){			asteroids[i].draw(g);			ship.draw(g);			//System.out.println(ship.xVelocity);		}					 //draw the ship			g2d1.setColor(Color.cyan); //Display level number in top left corner			g2d1.drawString("Level " + level,20,20);			//						gfx.drawImage(img,0,0,this);			repaint();						}};mainpanel.setBackground(new Color(0,0,0));mainpanel.addMouseMotionListener(this);mainpanel.add(exit);mainpanel.add(scorefield);//mainpanel.add(pause);mainpanel.setLayout(getLayout());this.add(mainpanel);this.setVisible(true);initialize();/*final float SAMPLE_RATE = 8000f;int freq=100;double freq1=1;//while(true)AudioFormat af = new AudioFormat(SAMPLE_RATE,8,1,true,true); SourceDataLine sdl;try {	sdl = AudioSystem.getSourceDataLine(af); sdl.open(af); sdl.start(); while(true){byte[] buf = new byte[(int)SAMPLE_RATE / 1000]; for (int i=0; i<buf.length; i++) {     double angle = i / (SAMPLE_RATE / freq) * freq1 * Math.PI;     buf[i] = (byte)(Math.sin(angle) * 127.0 * .4F);     freq=Math.abs((int)((ship.getXVel()+    		 ship.getYVel())*2000)/20);     System.out.println(freq);		//*2000/20;    sdl.write(buf,0,buf.length); //sdl.flush(); }}} catch (LineUnavailableException e1) {	// TODO Auto-generated catch block	e1.printStackTrace();} // shape the front and back*/}public void initialize(){	this.isDoubleBuffered();	this.isActive();	shots = new ArrayList<Shot>(41);	//41 is a shot's life period plus one.	//since at most one shot can be fired per frame,	//there will never be more than 41 shots if each one only	//lives for 40 frames.	numAsteroids=0;	level=0; //will be incremented to 1 when first level is set up	astRadius=60; //values used to create the asteroids	minAstVel=.5;	maxAstVel=5;	astNumHits=3;	astNumSplit=2;	endTime=0;	startTime=0;	framePeriod=25;	addKeyListener(this); //tell it to listen for KeyEvents	dim=getSize();	img=createImage(dim.width, dim.height);	g=img.getGraphics();	ship=new Ship(250,250,0,.35,.98,.1,1);//	thread=new Thread(this);	//thread.start();	//this.run();	mainThread();	//keys.start();}			public void update(Graphics gfx){					paint(gfx);					// paint(g);					}public void setUpNextLevel(){//start new level with one more asteroid	level++;	// create a new, inactive ship centered on the screen	//  .35 for acceleration, .98 for velocityDecay, and	// .1 for rotationalSpeed	//ship=new Ship(250,250,0,.35,.98,.1,10);	numShots=0; //no shots on the screen at beginning of level	shooting=false;	//create an array large enough to hold the biggest number	//of asteroids possible on this level (plus one because	//the split asteroids are created first, then the original	//one is deleted). The level number is equal to the	//number of asteroids at it's start.	asteroids=new Asteroid[level *	((int)Math.pow(astNumSplit,astNumHits-1)+1)+((int)Toolkit.getDefaultToolkit().getScreenSize().getWidth()/10)];				numAsteroids=level+6;							//create asteroids in random spots on the screen	for(int i=0;i<numAsteroids;i++)		asteroids[i]=new Asteroid((double)(Math.random()*dim.width),		(double)(Math.random()*dim.height),minAstVel,		maxAstVel,astNumHits,astNumSplit,3);}		/*public void run(){	while(true){				if(this.paused==false){			System.out.println("aagh");	mainThread();}	}	}*/		void mainThread(){			for(;;){			//while(paused==false){				//System.out.println("Yah");				//while(paused==false){		//Start shooting if ctrl is pushed		//else shooting=false;			//keys.run();//.start();	/*	try {			keys.wait(10);		} catch (InterruptedException e1) {			// TODO Auto-generated catch block			e1.printStackTrace();		}*/							startTime=System.currentTimeMillis();		//start next level when all asteroids are destroyed		if(paused==false){		if(numAsteroids<=0)			setUpNextLevel();				ship.move(dim.width,dim.height);				// move the ship				//move shots and remove dead shots				for(int i=0;i<numShots;i++){					shots.get(i).move(dim.width,dim.height);					//removes shot if it has gone for too long					//without hitting anything					if(shots.get(i).getLifeLeft()<=0){						//shifts all the next shots up one						//space in the array						deleteShot(i);						i--; // move the outer loop back one so						// the shot shifted up is not skipped					}				}			/*for(Shot shot:shots){			shot.move(dim.width,dim.height);			if(shot.getLifeLeft()<=0){				shots.remove(shot);			}		}*/			//move asteroids and check for collisions			updateAsteroids();			if(shooting && ship.canShoot()==true){			//add a shot on to the array				shots.add(ship.shoot());				numShots++;				numShots=shots.size();			}						repaint();		}			try{				endTime=System.currentTimeMillis();					if(framePeriod-(endTime-startTime)>0)						Thread.sleep(framePeriod-(endTime-startTime));			    }catch(InterruptedException e){			}//if(paused==true){					//paused=false;				//return;			//}			/*try {				keys.wait(10);			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();							}*/			//}					//}paused=false;				}		}		private void deleteShot(int index){						//delete shot and move all shots after it up in the array			numShots--;			shots.remove(index);		}		void asteroidBoom(){			try {///GameV2/src/resources/Troll_Song.wav				audio = new SoundLoader("/resources/Asteroid_Boom.wav",false);			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			audiothread=new Thread(audio);			//audio.playSound();			audiothread.run();		}		private void deleteAsteroid(int index){			//delete asteroid and shift ones after it up in the array			asteroidBoom();			numAsteroids--;			for(int i=index;i<numAsteroids;i++)				asteroids[i]=asteroids[i+1];				asteroids[numAsteroids]=null;		}	    	private void addAsteroid(Asteroid ast){					//adds the asteroid passed in to the end of the array	    		asteroids[numAsteroids]=ast;	    		numAsteroids=numAsteroids+1;	    	}			private void updateAsteroids(){				for(int i=0;i<numAsteroids;i++){					// move each asteroid					asteroids[i].move(dim.width,dim.height);					//check for collisions with the ship, restart the					//level if the ship gets hit					if(asteroids[i].shipCollision(ship)&&ship.isActive()){						//level--; //restart this level						enter=false;						ship.resetShip();	        				return;			    		}		    			//check for collisions with shots 				for(int j=0;j<numShots;j++){														if(asteroids[i].shotCollision((int)shots.get(j).getX(),(int)shots.get(j).getY())){						score=score+10;						//score1=("Score: "+score);																	scorefield.setText("Score: "+String.valueOf(score));																	//if the shot hit an asteroid, delete the shot					    deleteShot(j);						//split the asteroid up if needed				if(asteroids[i].getHitsLeft()>1){					for(int k=0;k<asteroids[i].getNumSplit();					    k++)						addAsteroid(					    asteroids[i].createSplitAsteroid(						minAstVel,maxAstVel));						}						//delete the original asteroid						deleteAsteroid(i);						j=numShots; //break out of inner loop - it has						//already been hit, don't need to check						//for collision with other shots						i--; //don't skip asteroid shifted back into						//the deleted asteroid's position			}		}	}}public static void main(String args[]){	setasteroidz(new AsteroidsGame("Asteroids Game"));	}					synchronized public void keyPressed(KeyEvent e){							//keys.yield();	if(e.getKeyCode()==KeyEvent.VK_ENTER){		enter = true;	}	if (enter==true){	//These first two lines allow the asteroids to move	//while the player chooses when to enter the game.	//This happens when the player is starting a new life.	if(ship.isActive()==false)		ship.setActive(true);		//else{		//paused=!paused;} //enter is the pause button			if(ship.isActive()==false){		return;					}else{		//paused or ship is inactive, do not respond		//to the controls except for enter to unpause		if(e.getKeyCode()==KeyEvent.VK_UP)			ship.setAccelerating(true);		if(e.getKeyCode()==KeyEvent.VK_LEFT)			ship.setTurningLeft(true);		if(e.getKeyCode()==KeyEvent.VK_RIGHT)			ship.setTurningRight(true);		if(e.getKeyCode()==KeyEvent.VK_SPACE)		    shooting=true; //Start shooting if ctrl is pushed			}}	//try {	//    keys.join();	   // keys.interrupt();					//	} catch (InterruptedException e1) {		// TODO Auto-generated catch block	//	e1.printStackTrace();	//}}/*@Overridesynchronized public void keyPressed(final KeyEvent e){											 keys=new Thread(){		    @Override		    public void run(){				if(e.getKeyCode()==KeyEvent.VK_ENTER){					enter = true;				}				if (enter==true){					//These first two lines allow the asteroids to move					//while the player chooses when to enter the game.					//This happens when the player is starting a new life.				    if(ship.isActive()==false)						ship.setActive(true);						//else{						//paused=!paused;} //enter is the pause button															if(ship.isActive()==false) //if the game is						return; //paused or ship is inactive, do not respond								//to the controls except for enter to unpause														if(e.getKeyCode()==KeyEvent.VK_UP&&ship.isAccelerating()==false)						ship.setAccelerating(true);						//tone.runTone(20,1,false,false,false,.6F);																							if(e.getKeyCode()==KeyEvent.VK_LEFT&&ship.isTurningLeft()==false)						ship.setTurningLeft(true);																if(e.getKeyCode()==KeyEvent.VK_RIGHT&&ship.isTurningRight()==false)						ship.setTurningRight(true);				}}}; keys.start();		//Thread.yield();		new Thread(){		@Override	    public void run(){											if(e.getKeyCode()==KeyEvent.VK_SPACE&&shooting==false){				shooting=true;			}}}.start();			//Start shooting if ctrl is pushed			//else shooting=false;			//.notify();	  // try {	//		keys.wait(10);	//	} catch (InterruptedException e1) {			// TODO Auto-generated catch block	//		e1.printStackTrace();		//}		//Thread.currentThread().interrupt();}*/public void setPaused(boolean p){	paused=p;}public void keyReleased(KeyEvent e){		if(e.getKeyCode()==KeyEvent.VK_UP&&ship.isAccelerating()==true)		ship.setAccelerating(false);	if(e.getKeyCode()==KeyEvent.VK_LEFT&&ship.isTurningLeft()==true)		ship.setTurningLeft(false);	if(e.getKeyCode()==KeyEvent.VK_RIGHT&&ship.isTurningRight()==true)		ship.setTurningRight(false);	if(e.getKeyCode()==KeyEvent.VK_SPACE&&shooting==true)		shooting=false;	if(e.getKeyCode()==KeyEvent.VK_ESCAPE){		paused=true;		mainpanel.add(pause);//paused;		//notify();	}	//if(e.getKeyCode()==KeyEvent.VK_2){		//paused=false;	//}	//Thread.currentThread().notify();}@Overridepublic void keyTyped(KeyEvent e){	}@Overridepublic void actionPerformed(ActionEvent a) {    if(a.getSource().equals(exit)){		Runtime.getRuntime().exit(0);	}	if(exit.isSelected()){		exit.setBorder(BorderFactory.createBevelBorder(1));	}	else if(exit.isSelected()==false){		exit.setBorder(BorderFactory.createRaisedSoftBevelBorder());	}	if(a.getSource().equals(pause.resume)){		setPaused(false);		System.out.println("yep");		//AsteroidsGame.getasteroidz().mainThread();		//System.out.println("yep");		mainpanel.remove(pause);	}}public static AsteroidsGame getasteroidz() {	return asteroidz;}public static void setasteroidz(AsteroidsGame asteroidz) {	AsteroidsGame.asteroidz = asteroidz;}@Overridepublic void mouseDragged(MouseEvent e) {	// TODO Auto-generated method stub			}@Overridepublic void mouseMoved(MouseEvent e) {	// TODO Auto-generated method stub					}}